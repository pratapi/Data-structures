// Unidirected Graph implementation : Adjacency List
#include <iostream>
#include <list>
using namespace std;

// A structure to represent an adjacency list node
struct Node
{
	int v;
	Node * next;
};

// List of Head ptr's to each linked list
struct HeadPtrList
{
	Node * head;
};

// creating new node or adjacent edge
Node * CreateNode(const int & v )
{
	Node * newNode = new Node();
	newNode->v = v;
	newNode->next = NULL;
	return newNode;
}

class Graph
{
	int nV; // no of vertices
	HeadPtrList * listofHeadptr; // ptr to head ptr's list

public:
	Graph();
	void addEdge(int u , int v);
	void Print();
	void BFS(int src);
	void DFS(int src);
	int NoofVertices() { return this->nV; }
};

// initializing graph
Graph::Graph()
{
	int V;
	printf("Enter the number of vertices for Graph G \n");
	scanf_s("%d", &V);
	this->nV = V; // setting number of vertices
	this->listofHeadptr = new HeadPtrList[V]; // creating head ptr's list with no. of vertices
	for(int i =0; i < V; i++)
		this->listofHeadptr[i].head = NULL; // setting first whole list to NULL

}

// adding edge for undirected graph
void Graph::addEdge(int u, int v)
{
	// Check for duplicacy
	Node * chkEdge = this->listofHeadptr[u].head;
	while(chkEdge)
	{
		if(chkEdge->v == v)
		{
			return; // duplicate Edge found
		} 
		else 
		{ chkEdge = chkEdge->next;}
	}

	// undirected graph firest create from u->v then v->u
	Node * newEdge_u = CreateNode(v);
	newEdge_u->next = this->listofHeadptr[u].head;
	this->listofHeadptr[u].head = newEdge_u;

	Node * newEdge_v = CreateNode(u);
	newEdge_v->next = this->listofHeadptr[v].head;
	this->listofHeadptr[v].head = newEdge_v;
}

// BFS
void Graph::BFS(int src)
{
	// create bool array corresponds to vertices considering false (i.e not visited )
	bool * bVisited = new bool[this->NoofVertices()];
	for(int i = 0; i < this->NoofVertices(); i++)
		bVisited[i] = false;

	// create queue for BFS
	list<int> queue;

	// mark the current node visited and queue it
	bVisited[src] = true;
	queue.push_back(src);

	printf_s("BFS : ");

	while(!queue.empty())
	{
		// deueue the vertex from queue and print it
		src = queue.front();
		printf("/n %d \n", src);
		queue.pop_front();

		// Get all adjacent vertices of the dequeued vertex s
        // If a adjacent has not been visited, then mark it visited
        // and enqueue it
		Node* iHead = this->listofHeadptr[src].head;
		while(iHead)
		{
			int v = iHead->v;
			if(!bVisited[v])
			{
				bVisited[v] = true;
				queue.push_back(v);
			}
			iHead = iHead->next;
		}
	}
	delete [] bVisited;
}

void Graph::DFS(int src)
{
	// create bool array corresponds to vertices considering false (i.e not visited )
	bool * bVisited = new bool[this->nV];
	for(int i=0; i<this->nV; i++)
		bVisited[i] = false;

	// creating stack
	list<int> stack;

	// push the current node on the stack and marked it as visited
	stack.push_back(src);
	bVisited[src] = true;

	while(!stack.empty())
	{
		src = stack.back();
		printf_s("%d  ", src);
		stack.pop_back();

		// get the one of adajcent node
		Node* iHead = this->listofHeadptr[src].head;
		while(iHead)
		{
			int v = iHead->v;
			if(!bVisited[v])
			{
				bVisited[v] = true;
				stack.push_back(v);
			}
			iHead = iHead->next;
		}
	}

	delete [] bVisited;
}

// Utility function to print array of adjacency list
void Graph::Print()
{
	for(int u=0; u < this->nV ; u++)
	{
		Node * iHead = this->listofHeadptr[u].head;
		printf("\n Adjacency list of vertex %d\n head ", u);
		while(iHead)
		{
			printf("-> %d", iHead->v);
			iHead = iHead->next;
		}
		printf("\n");
	}
}

// Driver's Program
int main()
{
	Graph graph;
	int E=0,u=-1,v=-1;
	printf("Enter the number of Edges \n");
	scanf_s("%d", &E);
	printf("Enter the Edges in form of u v \n");
	while(E--)
	{
		scanf_s("%d %d", &u, &v);
		if( (u>=0) && (u < graph.NoofVertices()) && (v >= 0) && (v < graph.NoofVertices()))
		 { 
			 graph.addEdge(u, v);
		} else
		{
			printf("Incorrect Edge please enter again");
			++E;
		}
	}

	// Print Graph
	graph.Print();

	// BFS traversal of graph
	graph.BFS(0);

	// DFS traversal of graph
	graph.DFS(0);

	return 0;
}
